# modbus-robustness-tester

Modbus Robustness Tester は、Modbus通信を含む機器に対して、
想定外の通信が行われた場合でもクラッシュやハングアップを起こさないことを確認するための耐性評価ツールです。

本ツールは、正常系および異常系のModbusコマンドを送信し、
機器が最低限の安定性を維持できているかを確認することを目的としています。

## 1.なぜ作ったか

EUサイバーレジリエンス法（Cyber Resilience Act, CRA）をはじめとする近年の動きにより、  
製品には「正しく使われたときに動作すること」だけでなく、  
**誤った使われ方や想定外の通信に対しても壊れないこと** が求められるようになってきました。

Modbus は産業用途で広く利用されている一方で、通信仕様が比較的シンプルなため、

- 不正なファンクションコード  
- アドレス範囲外のアクセス  
- 極端なレジスタ数指定  
- 仕様外・想定外のリクエストの組み合わせ  

といった通信を受けた際に、実装の弱さが表面化しやすい側面があります。

このツールは、そうした状況を **意図的に発生させるテスト（耐性・ロバストネス試験）** を、  
手軽かつ再現性をもって実施するために作成しました。

正常系の通信確認だけでなく、

- 例外応答が正しく返るか  
- 不正なリクエストを受けても装置が停止・クラッシュしないか  
- 通信エラー後に正常な状態へ復帰できるか  

といった観点での評価を行うことを目的としています。

規制対応や品質向上のための  
**「壊しにいくテスト」** を支援するためのツールです。

## 2.対象とする環境

本ツールは以下の環境で動作確認を行っています。

- **OS**: Windows 10 / 11（※ macOS / Linux でも Python が動作すれば利用可能）
- **Python**: 3.10 〜 3.12
- **必要ライブラリ**
  - `pyserial>=3.5`（シリアルポート経由でModbus通信を行うために使用）  

---

## 3.クイックスタート

### 3.1. EXE版を使う

#### 3.1.1. ダウンロード
Windows 向けの実行ファイル（exe）は  
GitHub Releases ページからダウンロードできます。

➡ **[Releases ページはこちら](https://github.com/prevalmam/modbus-robustness-tester/releases)**

最新バージョンの Assets から  
`mb-robust.exe` をダウンロードしてください。

#### 3.1.2. SHA-256（検証用）

配布している実行ファイルの SHA-256 ハッシュ値は  
Releases の Assets に含まれる `SHA256SUMS.txt` に記載しています。

ダウンロード後、以下のコマンドで検証できます。

```powershell
certutil -hashfile mb-robust.exe SHA256
```
出力されたハッシュ値が SHA256SUMS.txt に記載されている値と一致すれば、
ファイルが改ざんされていないことを確認できます。

### 3.2. ソースコードから使う

#### 3.2.1. git clone + pip install
次に示すコマンドを実行して，ソースコードをクローンし，pip でインストールします。

```powershell
git clone https://github.com/prevalmam/modbus-robustness-tester.git
cd modbus_robustness_tester
pip install .
```

#### 3.2.2. 使い方

1. コマンドラインから以下を実行します。

```powershell
mb-robust
```
## 4.使い方
## 4. 使い方

### 4.1. Read (0x03) テストの実行例

このテストは、指定したスレーブアドレスに対して  
**Read Holding Registers（Function Code: 0x03）** を用いた  
読み出しリクエストを連続的に送信し、応答の健全性を確認するものです。

#### 手順

1. **Port / Baud Rate / Parity** を設定します 
2. **Read (0x03)** タブを選択します 
2. **Slave Addr** にテスト対象のスレーブアドレスを指定します  
3. **Start Addr / End Addr** にテストしたいレジスタアドレス範囲を指定します  
4. **Min Regs / Max Regs** に読み出しレジスタ数の最小値・最大値を指定します  
5. 「**Connect**」ボタンを押して対象機器に接続します  
6. 「**Read (0x03)**」ボタンを押してテストを開始します  

#### 動作内容

テスト開始後、以下の条件の組み合わせでリクエストが順番に送信されます。

- アドレス：Start Addr ～ End Addr  
- レジスタ数：Min Regs ～ Max Regs  

各リクエストについて、

- 正常応答が返るか  
- 例外応答（Exception）が正しく返るか  
- タイムアウトや CRC エラーが発生しないか  

を確認し、その結果をログに記録します。

#### 想定される用途

- レジスタマップ境界付近の挙動確認  
- 想定外のレジスタ数指定に対する耐性確認  
- 実装依存の不具合（クラッシュ・無応答）の洗い出し  

正常系から準異常系までをまとめて確認したい場合に有効です。

### 4.2. Illegal Function テストの実行例

このテストは、Modbus 仕様上は存在するものの、  
対象機器では **サポートされていない、もしくは想定していない  
ファンクションコード** を送信し、機器の耐性を確認するためのものです。

例外応答が正しく返るか、あるいは不正なリクエストを受けても  
機器が停止・クラッシュしないかを確認することを目的としています。

#### 手順

1. **Port / Baud Rate / Parity** を設定します
2. **Illegal Func** タブを選択します  
2. **Slave Addr** にテスト対象のスレーブアドレスを指定します  
3. **Addr / Reg Num** に送信するリクエストのアドレスとレジスタ数を指定します  
4. テストしたい **Function Code** をチェックボックスで選択します  
   - Write 系の Function Code（例：0x05, 0x06, 0x0F, 0x10）は  
     デフォルトで **アンチェック** されています  
   - Write 系コマンドはデバイス状態を変更する可能性があるため、  
     本テストでの実行は **非推奨** です  
   - Write 系 Function Code を使用する場合は、  
     テスト環境および影響範囲を十分に理解した上で実施してください  
5. 「**Connect**」ボタンを押して対象機器に接続します  
6. 「**Send (Illegal)**」ボタンを押してテストを開始します  

#### 動作内容

本テストでは、**Read Holding Registers（Function Code: 0x03）** の  
リクエストフォーマットをベースとし、

- スレーブアドレス  
- アドレス（Addr）  
- レジスタ数（Reg Num）  

はそのままに、**Function Code のみを変更したリクエスト**を  
選択されたコード分、順番に送信します。

つまり、

- 通信フレームの構造自体は正しい  
- Function Code だけが仕様外・想定外  

という状態を意図的に作り出し、機器の応答を確認します。

各リクエストについて、

- 例外応答（Exception）が正しく返るか  
- 無応答・タイムアウトが発生しないか  
- 不正な Function Code によって通信が不安定にならないか  

をログに記録します。

#### 想定される用途

- 未サポート機能に対する例外応答の確認  
- 想定外の Function Code に対する耐性評価  
- 悪意のある、もしくは誤った通信を受けた場合の挙動確認  

製品のロバスト性評価や、規制・品質対応の確認に有効です。

